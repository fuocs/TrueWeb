\label{chap:implementation}

% This chapter describes the concrete implementation of TrueWeb, focusing on engineering decisions, module interfaces, concurrency design, communication between the browser extension and desktop application, configuration management, and failure-handling strategies. This chapter complements the conceptual descriptions presented in the Methodology and Scoring System chapters by explaining how they are realized in a practical software system.

\section{System Decomposition and Code Organization}

\begin{figure}[h]
    \centering
    \fbox{
        \begin{minipage}{0.5\textwidth}
            \dirtree{%
                .1 TrueWeb.
                .2 backend/.
                .3 services/.
                .3 utils/.                
                .2 frontend/.
                .3 media/.
                .2 extension/.
                .3 icon/.
                .2 app.py.
                .2 main.py.
            }
        \end{minipage}
    }
    \caption{TrueWeb's Source Code Oganization}
\end{figure}

The implementation is organized into three layers:
\begin{itemize}
    \item \textbf{Presentation layer (PyQt6)}: implemented in \texttt{frontend/}. It handles navigation, user interaction, progress visualization, and final result presentation.
    \item \textbf{Application layer (Controller)}: implemented primarily in \texttt{app.py}. It connects UI signals to backend actions, manages application state (login, pages, system tray behavior), and starts the local server thread.
    \item \textbf{Analysis layer (Backend)}: implemented in \texttt{backend/}. It collects website data, executes risk analysis modules, and aggregates results into a final trust score.
\end{itemize}

In addition, the \texttt{extension/} directory contains the browser extension responsible for extracting URLs from the user’s browsing context and forwarding them to the desktop application.
\subsection{Inter-layer Data Flow}

Understanding how data flows between layers is essential for comprehending the system's behavior. The following describes the typical request-response cycle when a user initiates a website analysis:

\begin{enumerate}
    \item \textbf{User Input → Controller}: The user enters a URL in the frontend interface (or the browser extension forwards one). The frontend emits a signal that is captured by \texttt{app.py}.
    
    \item \textbf{Controller → Backend}: The controller instantiates an \texttt{AnalysisWorker} (a QThread subclass) and passes the URL to \texttt{backend/scoring\_system.py}, which orchestrates the analysis pipeline.
    
    \item \textbf{Backend Internal Flow}: 
    \begin{itemize}
        \item \texttt{scoring\_system.py} first performs a connectivity check
        \item If reachable, it fetches shared resources (HTML, WHOIS data) once
        \item It then dispatches parallel tasks to individual scoring modules in \texttt{calculate\_score.py}
        \item Each module (e.g., \texttt{reputation.py}, \texttt{AI\_confidence.py}, \texttt{ssl\_certificate.py}) returns a standardized result dictionary
    \end{itemize}
    
    \item \textbf{Backend → Controller}: The aggregated results (final score, per-module subscores, details, screenshots) are returned to the worker thread, which emits a \texttt{finished} signal.
    
    \item \textbf{Controller → Frontend}: The controller receives the signal and updates the result page with the trust score, detailed breakdown, AI summary, and screenshot carousel.
\end{enumerate}

\begin{figure}[h]
    \centering
    \begin{tikzpicture}[node distance=1.8cm, auto,
        block/.style={rectangle, draw, text width=2.8cm, text centered, minimum height=1cm, font=\small},
        arrow/.style={->, >=stealth, thick}]
        
        % Nodes
        \node[block] (frontend) {Frontend\\(PyQt6 UI)};
        \node[block, right=of frontend] (controller) {Controller\\(app.py)};
        \node[block, right=of controller] (backend) {Backend\\(scoring\_system)};
        \node[block, below=1.2cm of backend] (modules) {Analysis Modules\\(9 parallel tasks)};
        
        % Arrows
        \draw[arrow] (frontend) -- node[above, font=\scriptsize] {URL input} (controller);
        \draw[arrow] (controller) -- node[above, font=\scriptsize] {Start worker} (backend);
        \draw[arrow] (backend) -- node[right, font=\scriptsize] {Dispatch} (modules);
        \draw[arrow] (modules.west) -- ++(-1.5,0) |- node[near start, left, font=\scriptsize] {Results} (backend.south west);
        \draw[arrow, dashed] (backend.north) -- ++(0,0.5) -| node[near end, above, font=\scriptsize] {Signal} (controller.north);
        \draw[arrow, dashed] (controller.south) -- ++(0,-0.5) -| node[near end, below, font=\scriptsize] {Update UI} (frontend.south);
    \end{tikzpicture}
    \caption{Data flow between system layers during website analysis}
    \label{fig:data-flow}
\end{figure}

This layered architecture ensures clear separation of concerns: the frontend remains responsive (analysis runs in a separate thread), the controller manages state transitions, and the backend focuses purely on data collection and analysis logic.
\section{Backend Analysis Pipeline}
The backend analysis pipeline follows a sequence of optimized steps:

\subsection{Early Connectivity Check}
Before launching resource-intensive operations, the system performs a reachability check. If the target website is unreachable due to timeout, DNS failure, or connection error, the pipeline terminates early and returns an error state. This fast-fail mechanism prevents unnecessary API usage and improves user experience.

\begin{lstlisting}[language=Python, caption=Implementation of Fast-fail Mechanism ]
# Phase 1: Quick connectivity check before full analysis
is_reachable, error_msg = quick_connectivity_check(url, timeout=3)

if not is_reachable:
    # Terminate the pipeline early if the website is down
    return {
        'error': True,
        'error_message': error_msg,
        'url': url
    }

# Proceed with parallel analysis only if reachable
print("Website is reachable, proceeding with analysis...")
\end{lstlisting}
\subsection{Shared Data Fetching}
The system retrieves the website HTML content once and reuses it across multiple modules, including:
\begin{itemize}
    \item the AI-based content analysis module, and
    \item the HTML heuristic and behavioral analysis module.
\end{itemize}
This approach avoids redundant network requests and improves determinism.

\begin{lstlisting}[language=Python, caption=Shared Data Fetching in scoring\_system.py]
# Single fetch operation for shared resources
raw_html, extracted_text = url_utils.fetch_raw_html(url=url)

# Distributing shared data to independent analysis modules
tasks = {
    'HTML analysis': lambda: calculate_score.html_score(url=url, html_content=raw_html),
    'AI analysis': lambda: calculate_score.AI_score(url=url, extracted_text=extracted_text)
}
\end{lstlisting}

\subsection{Parallel Module Execution}
The following analysis modules are executed concurrently:
\begin{itemize}
    \item SSL/TLS certificate details and protocol indicators,
    \item protocol security checks (e.g., HTTP versus HTTPS),
    \item HTML structure and behavioral heuristics,
    \item reputation databases (VirusTotal and Google Safe Browsing),
    \item domain pattern analysis (typosquatting and suspicious strings),
    \item server reliability and domain age indicators,
    \item crowdsourced user review evaluation.
\end{itemize}

\subsection{Retry Strategy and Graceful Degradation}
External network calls and third-party APIs are subject to transient failures such as rate limits or timeouts. Each module is therefore executed with a retry mechanism using exponential backoff. If all retries fail, the module returns:
\begin{itemize}
    \item a safe fallback score accompanied by an explanatory message in the \texttt{details} field, and
    \item an error flag allowing the UI to highlight missing or incomplete evidence.
\end{itemize}
This design ensures that individual module failures do not compromise the overall analysis.

\section{Score Aggregation (Implementation View)}
TrueWeb aggregates module outputs using a weighted normalized average. The conceptual design of the scoring model, including weights and thresholds, is described in the Scoring System chapter (see Figure~\ref{fig:trust-score-weights}).


From an implementation perspective:
\begin{itemize}
    \item each module produces a normalized sub-score $s_i \in [0,1]$,
    \item each criterion has an associated weight $w_i$,
    \item the final score is mapped to a 0--5 scale for user interpretability.
\end{itemize}

\section{Module Contract and Result Normalization}
To ensure consistency between the UI and the scoring pipeline, each analysis module adheres to a common output contract:
\begin{itemize}
    \item a \textbf{sub-score} in the range $[0,1]$, where higher values indicate lower risk,
    \item a \textbf{details} field containing human-readable explanations, directly reused by the UI,
    \item optional metadata used for debugging and richer result visualization (e.g., certificate issuer names or HTML heuristic ratios).
\end{itemize}
\begin{lstlisting}[language=Python, caption=Sample report return function]
def _create_report():
    return {
        "score": 0.0,
        "details": []
}
\end{lstlisting}
This contract enables independent evolution of individual modules while preserving a stable aggregation and presentation interface.

\section{Background Operation (System Tray Mode)}
TrueWeb is designed to run non-intrusively in the background. At runtime, the desktop application creates a system tray icon and can keep running even when the main window is hidden. When the user closes the main window and \textit{minimize-to-tray} is enabled, the close event is intercepted: the UI is hidden while the process remains active.

This behavior is important for the extension-to-app workflow. While the UI is hidden, the localhost integration server can continue listening on \texttt{127.0.0.1} and receive URLs from the browser extension. Users can then restore the window from the tray to view progress and results.

From an implementation perspective, PyQt6 provides this capability via \texttt{QSystemTrayIcon} and an event filter for the window close event. The application also disables the default behavior of quitting when the last window closes to ensure stable background execution.

\begin{lstlisting}[language=Python, caption=System tray event handling implementation]
def eventFilter(self, source, event):
    if source == self.window and event.type() == QEvent.Type.Close:
        # CASE 1: Background mode (Minimize to Tray) is ENABLED
        if self.minimize_to_tray_mode:
            event.ignore()
            self.window.hide() 
            self.tray_icon.showMessage(
                "TrueWeb",
                "The application is running in the background in the system tray.",
                QSystemTrayIcon.MessageIcon.Information,
                2000
            )
            return True 
        # CASE 2: Background mode is DISABLED (User wants to exit completely)
        else:
            event.accept()
            self.tray_icon.hide()
            self.app.quit()
            return True   
    return super().eventFilter(source, event)
\end{lstlisting}

\section{Concurrency Design and Responsiveness}
TrueWeb employs concurrency at multiple levels to maintain responsiveness and reduce analysis latency.

\subsection{UI-level Concurrency (QThread)}
Website analysis is executed in a background worker thread to prevent blocking the PyQt6 event loop. The \texttt{worker} emits:
\begin{itemize}
    \item a \texttt{progress} signal to update loading indicators, and
    \item a \texttt{finished} signal containing the final trust score, per-criterion breakdown, and auxiliary data such as screenshots.
\end{itemize}

\subsection{Backend-level Concurrency (ThreadPoolExecutor)}
Within the backend analysis layer, independent checks are executed in parallel using a thread pool. This design reduces total scan time by approximating the latency of the slowest module rather than the cumulative latency of all modules.

\section{Configuration Management and Secrets}
Sensitive configuration values are loaded from environment variables (via a \texttt{.env} file during development). Configuration categories include:
\begin{itemize}
    \item reputation service API keys (VirusTotal and Google Safe Browsing),
    \item AI analysis keys (Groq), with support for multiple keys to mitigate rate limiting,
    \item Firebase credentials for authentication and data storage.
\end{itemize}

This approach enables secure packaging and deployment without embedding secrets directly in the source code.

\begin{lstlisting}[language=java, caption={.env file example}]
# 1. Admin SDK Configuration
SERVICE_ACCOUNT_CONFIG='YOUR_SERVICE_ACCOUNT_JSON_HERE'

# Google OAuth client config JSON 
GOOGLE_CLIENT_CONFIG='YOUR_GOOGLE_CLIENT_CONFIG_JSON_HERE'

# 2. Web API Configuration (For Authentication/Password Verification)
FIREBASE_WEB_API_KEY='YOUR_FIREBASE_WEB_API_KEY_HERE'

# 3. API Keys for Security Checks
VIRUSTOTAL_API_KEY='YOUR_VIRUSTOTAL_API_KEY_HERE'

# Get your Google Safe Browsing API key from: https://console.cloud.google.com/
GOOGLE_SAFE_BROWSING_API_KEY='YOUR_GOOGLE_SAFE_BROWSING_API_KEY_HERE'

# 4. AI Analysis (Groq API)
# You can provide multiple keys separated by commas for load balancing
# Example: GROQ_API_KEY='key1,key2,key3'
GROQ_API_KEY='YOUR_GROQ_API_KEY_HERE'
\end{lstlisting}

\section{Security Considerations During Analysis}

A critical concern when analyzing potentially malicious websites is the risk that the analysis process itself could be compromised by executing malicious code from the target website. TrueWeb addresses this security challenge through a multi-layered defense strategy that isolates the analysis process from the host system.

\subsection{HTML Fetching: Read-Only Static Analysis}

The primary data collection mechanism uses the Python \texttt{requests} library to fetch website content. This approach is inherently safe because:

\begin{itemize}
    \item \textbf{No JavaScript Execution:} The \texttt{requests.get()} method retrieves only the raw HTML source code as plain text. JavaScript code embedded in the HTML remains as static strings and is never executed.
    
    \item \textbf{DOM Parsing Only:} BeautifulSoup and lxml parse the HTML structure to extract text content and analyze DOM patterns. These parsers operate purely on the document structure---they do not interpret or execute any embedded scripts, event handlers, or dynamic content.
    
    \item \textbf{Network Isolation:} The fetching process makes a single HTTP request and does not follow external resource loads (images, fonts, additional scripts). This prevents the target website from initiating secondary attacks or tracking the analysis system.
\end{itemize}

\begin{lstlisting}[language=Python, caption=Safe HTML fetching without code execution]
# Fetch HTML content using requests (no JavaScript execution)
response = requests.get(url, timeout=20, verify=False)

# Parse HTML structure (static analysis only)
soup = BeautifulSoup(response.content, 'html.parser')

# Extract text content - scripts are removed but never executed
for script in soup(['script', 'style', 'noscript']):
    script.extract()  # Remove tags from DOM tree

text = soup.get_text(separator=' ', strip=True)
# Result: plain text content, all code removed
\end{lstlisting}

\subsection{Screenshot Capture: Sandboxed Browser Execution}

While the HTML fetching process is inherently safe, the screenshot capture module does require rendering the website in a real browser environment (Selenium WebDriver with Chrome). This component presents a potential attack surface, but TrueWeb implements multiple isolation mechanisms to mitigate risks:

\subsubsection{Headless Isolation}
The browser runs in headless mode (\texttt{--headless=new}), which provides several security benefits:
\begin{itemize}
    \item No graphical interface or window is created, preventing UI-based attacks (e.g., fake download dialogs, phishing overlays).
    \item The headless environment runs with restricted permissions and cannot access the user's desktop or interact with other applications.
    \item Even if malicious code attempts to open new windows or display alerts, these operations are suppressed in headless mode.
\end{itemize}

\subsubsection{Sandboxing and Resource Restrictions}
The Selenium WebDriver is configured with multiple security-hardening flags:

\begin{lstlisting}[language=Python, caption=Selenium security configuration]
chrome_options = Options()
chrome_options.add_argument("--headless=new")           # Run without GUI
chrome_options.add_argument("--no-sandbox")             # Linux container isolation
chrome_options.add_argument("--disable-dev-shm-usage")  # Prevent memory attacks
chrome_options.add_argument("--disable-gpu")            # No GPU access
chrome_options.add_argument("--disable-extensions")     # No browser plugins
chrome_options.add_argument("--disable-images")         # Block image downloads
chrome_options.page_load_strategy = 'eager'             # Stop before full load

# Timeouts prevent infinite loops or resource exhaustion
driver.set_page_load_timeout(60)
driver.set_script_timeout(60)
\end{lstlisting}

These configurations enforce the following protections:
\begin{itemize}
    \item \textbf{No Extensions or Plugins:} All browser extensions are disabled, preventing malicious sites from exploiting extension vulnerabilities.
    
    \item \textbf{Image and Resource Blocking:} External images are not downloaded, reducing both bandwidth usage and the risk of malicious image payloads (e.g., EXIF exploits).
    
    \item \textbf{Script Timeout Limits:} JavaScript execution is limited to 60 seconds per page. Infinite loops or resource-exhaustion attacks are automatically terminated.
    
    \item \textbf{Page Load Strategy:} The browser stops loading as soon as the DOM is ready (eager mode), preventing delayed malicious script execution.
\end{itemize}

\subsubsection{Process Isolation and Cleanup}

Each screenshot capture runs in an isolated thread with automatic cleanup:

\begin{itemize}
    \item \textbf{Thread-Level Isolation:} If a malicious script causes a browser crash or deadlock, only that specific thread is affected. The main application and other analysis modules continue operating normally.
    
    \item \textbf{Automatic Cleanup:} After each screenshot attempt, the WebDriver instance is explicitly terminated using \texttt{driver.quit()}, ensuring all browser processes are killed and temporary files are removed.
    
    \item \textbf{Screenshot Folder Deletion:} All captured screenshots are stored in a hidden temporary directory that is automatically deleted when the application exits, preventing persistent malicious payloads from remaining on disk.
\end{itemize}

\begin{lstlisting}[language=Python, caption=Automatic browser cleanup]
try:
    driver = webdriver.Chrome(service=service, options=chrome_options)
    driver.get(url)
    driver.save_screenshot(output_path)
finally:
    if driver:
        driver.quit()  # Kill all browser processes
\end{lstlisting}

\subsection{No File Downloads or Installations}

The analysis pipeline is strictly read-only with multiple layers preventing automatic malicious file downloads:

\subsubsection{Requests Library: No Download Capability}
The primary data collection method using \texttt{requests.get()} is fundamentally incapable of triggering automatic downloads:
\begin{itemize}
    \item The library only retrieves the HTTP response body into memory as text or binary data.
    \item It does not interpret HTTP headers that trigger downloads (e.g., \texttt{Content-Disposition: attachment}).
    \item No file writing occurs unless explicitly programmed---TrueWeb only processes the response in-memory.
    \item Drive-by download attacks that rely on browser behavior (e.g., automatic file execution) have no effect, as \texttt{requests} is not a browser.
\end{itemize}

\subsubsection{Selenium WebDriver: Download Blocking Enforced}
While Selenium uses a real Chrome browser that could theoretically trigger downloads, TrueWeb explicitly configures Chrome to block all download attempts:

\begin{lstlisting}[language=Python, caption=Chrome preferences to block downloads]
# Additional security: Block all file downloads
prefs = {
    "download.default_directory": "/dev/null",  # Invalid path
    "download.prompt_for_download": False,
    "download.directory_upgrade": True,
    "safebrowsing.enabled": True,  # Block known malicious downloads
    "profile.default_content_setting_values.automatic_downloads": 2  # Block
}
chrome_options.add_experimental_option("prefs", prefs)
\end{lstlisting}

These preferences ensure:
\begin{itemize}
    \item \textbf{No Download Dialog:} Even if a website attempts to trigger a download, Chrome will not prompt the user or save any files.
    
    \item \textbf{Invalid Download Path:} Any download attempt is redirected to \texttt{/dev/null} (a non-existent location), causing the operation to fail silently.
    
    \item \textbf{Automatic Download Blocking:} Sites that attempt multiple automatic downloads are explicitly blocked by Chrome's content settings.
    
    \item \textbf{Safe Browsing Integration:} Chrome's built-in Safe Browsing feature blocks known malicious downloads before they can be initiated.
\end{itemize}

\subsubsection{No File Execution Pipeline}
Beyond blocking downloads, TrueWeb's architecture includes no mechanisms for:
\begin{itemize}
    \item Opening or executing downloaded files
    \item Extracting archives (ZIP, RAR, etc.)
    \item Processing Office documents, PDFs, or other potentially exploitable file formats
    \item Installing software or browser extensions from analyzed websites
\end{itemize}

The system's sole interaction with the target website is reading HTML content and capturing visual screenshots. No file system writes occur except for temporary screenshot images, which are automatically deleted on application exit.

\subsubsection{Protection Against Drive-by Download Attacks}

Drive-by download attacks typically exploit browser vulnerabilities or social engineering to automatically download and execute malware without user interaction. TrueWeb's defense against these attacks includes:

\begin{enumerate}
    \item \textbf{No User Profile Access:} The headless Chrome instance runs without loading user profiles, preventing attacks that target existing browser sessions or saved credentials.
    
    \item \textbf{Sandboxed Execution:} Even if a sophisticated exploit bypasses download blocking, the headless environment lacks the necessary permissions to install software or modify system files.
    
    \item \textbf{Process Termination:} The browser process is forcefully terminated after screenshot capture (via \texttt{driver.quit()}), destroying any malicious payload before it can persist or execute.
    
    \item \textbf{Ephemeral File System:} All screenshots are stored in a temporary hidden directory that is completely deleted when TrueWeb exits, leaving no trace of potentially malicious content.
\end{enumerate}

\subsection{Attack Surface Summary}

The following table summarizes the risk profile of each analysis component:

\begin{table}[H]
\centering
\begin{tabular}{|l|c|p{6cm}|}
\hline
\textbf{Component} & \textbf{Executes JS?} & \textbf{Security Measures} \\
\hline
HTML Fetching (requests) & No & Static text retrieval only, no code execution \\
\hline
BeautifulSoup Parsing & No & DOM structure analysis, scripts removed \\
\hline
Selenium Screenshots & Yes & Headless, sandboxed, timeouts, no downloads, isolated threads \\
\hline
\end{tabular}
\caption{Risk assessment and mitigation for analysis components}
\label{tab:security-measures}
\end{table}

\subsection{Practical Security Guarantees}

In practice, TrueWeb's security model provides the following guarantees:

\begin{enumerate}
    \item \textbf{No Persistent Infection:} Even if a malicious website exploits a browser vulnerability during screenshot capture, the infection is contained within the headless Chrome instance and is destroyed when the process terminates.
    
    \item \textbf{No User Data Exposure:} The headless browser runs without access to user profiles, cookies, or saved passwords. Malicious sites cannot steal credentials or session tokens.
    
    \item \textbf{No Network Propagation:} The analysis system does not expose services on the network. A compromised browser instance cannot pivot to attack other machines.
    
    \item \textbf{Fail-Safe Behavior:} If any analysis module crashes or times out, the system returns an error result rather than exposing partial data or leaving processes running.
\end{enumerate}

This defense-in-depth approach ensures that TrueWeb can safely analyze even highly malicious websites without compromising the host system's security.


% \section{Implementation Summary}
% This chapter demonstrated how the proposed system design and scoring methodology are realized in a robust, responsive, and extensible software architecture, bridging conceptual analysis with practical deployment considerations.