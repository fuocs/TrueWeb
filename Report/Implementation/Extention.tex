\section{Browser Extension Integration}
\subsection{User Interaction}
The extension provides multiple entry points to ensure a seamless user experience across different browsing habits.

\textbf{Context Menu:} Users can right-click on a hyperlink, a text selection, or any area within a webpage to select the "Scan this link with TrueWeb" option.
\begin{lstlisting}[language=java, caption=Right-click menu listener implementation]
chrome.runtime.onInstalled.addListener(() => {
    chrome.contextMenus.create({
        id: "scan-link-trueweb",
        title: "Scan this link with TrueWeb",
        // Displays when right-clicking on a link, the page, or a text selection
        contexts: ["link", "page", "selection"] 
    });
});
\end{lstlisting}

\textbf{Keyboard Shortcut:} The extension supports a dedicated hotkey, \texttt{Ctrl+Shift+Space}, allowing users to instantly trigger the extraction logic at the current cursor position without opening any menus.

\begin{lstlisting}[language=java, caption=Keyboard-shortcut declaration]
    "commands": {
      "copy-link-under-cursor": {
        "suggested_key": "Ctrl+Shift+Space",
        "description": "Copy the link currently under the mouse cursor"
      }
    }
\end{lstlisting}

\begin{lstlisting}[language=java, caption=Keyboard shortcut listener implementation]
chrome.commands.onCommand.addListener(async (command, tab) => {
    if (command === 'copy-link-under-cursor') {
        await handleCopy(active);
    }
});
\end{lstlisting}


\textbf{System Notifications:} Upon any interaction, the extension provides immediate feedback via Chrome desktop notifications. These alerts inform the user of the operation's status, such as successful data transmission, connection timeouts, or if the URL has already been analyzed by the system.

\begin{lstlisting}[language=java, caption=Notification implementation]
function notify(message) {
    chrome.notifications.create({
        type: 'basic',
        message: message,
        ...
    });
}
\end{lstlisting}

\subsection{Local Server Protocol}
\subsubsection{Protocol}
\begin{lstlisting}[language=java, caption=Fetch function implementation]
    const res = await fetch(`${LOCALHOST_URL}/download`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-Auth': LOCALHOST_TOKEN
        },
        body: JSON.stringify({ url: href }),
        signal: controller.signal
	});
\end{lstlisting}

The desktop application exposes a local-only HTTP endpoint:
\begin{itemize}
    \item \textbf{Endpoint:} \texttt{POST /download}
    \item \textbf{Body:} \texttt{\{ url: \ldots \}}
    \item \textbf{Authentication header:} \texttt{X-Auth: <token>}
\end{itemize}

The extension uses a short timeout to avoid blocking the browser UI when the desktop application is not running.
\subsubsection{Security Considerations}
\begin{itemize}
    \item \textbf{Local-only communication:} the extension communicates exclusively with \texttt{127.0.0.1} to limit network exposure.
    \item \textbf{Shared authentication token:} the local server validates requests using an \texttt{X-Auth} token to reduce accidental access by other local processes.
    \item \textbf{Recommended hardening:} future improvements include per-session tokens, rate limiting, and audit logging of analysis sessions.
\end{itemize}

\begin{lstlisting}[language=java, caption=Local server configuration]
const LOCALHOST_URL = 'http://127.0.0.1:38999'; 
const LOCALHOST_TOKEN = 'dev-token';            
const ENABLE_FORWARD_TO_APP = true;             
\end{lstlisting}
\subsection{URL Extraction Implementation}

The extension employs a multi-layered extraction strategy to ensure high accuracy and minimize data loss across various web structures:

\textbf{Standard Link Detection:} Automatically retrieves the \texttt{linkUrl} property via the Chrome Context Menus API when interacting with standard \texttt{<a>} tags.

\textbf{Text-to-URL Analysis:} Utilizes Regular Expressions (\verb|\^https?:\/\//|) to identify and extract functional URLs from selected plain text.


\begin{lstlisting}[language=Java, caption=extraction url implementation]
chrome.contextMenus.onClicked.addListener(async (info, tab) => {
    if (info.menuItemId === "scan-link-trueweb") {
        
        // PRIORITY 1: If Chrome identifies a standard link (<a> tag)
        if (info.linkUrl) {
            if (ENABLE_FORWARD_TO_APP) {
                await handOffToLocalhost(info.linkUrl);
            } else {
                notify('Detected Link: ' + info.linkUrl);
            }
        } 
        // PRIORITY 2: If text is highlighted (user selects link text)
        else if (info.selectionText && /^https?:\/\//.test(info.selectionText)) {
             if (ENABLE_FORWARD_TO_APP) {
                await handOffToLocalhost(info.selectionText.trim());
            }
        }
        // PRIORITY 3: Fallback to the "Link Under Cursor" logic
        else {
            await handleCopy(tab);
        }
    }
});
\end{lstlisting}

\textbf{Advanced Fallback (Link-Under-Cursor):} 
\begin{itemize}
    \item \textbf{Heuristic Anchor Resolving:} Traverses the DOM tree to find the nearest parent anchor tag or elements containing \texttt{data-href} attributes.
\begin{lstlisting}[language=Java, caption=Heuristic anchor resolving implementation]
function resolveAnchor(el) {
    if (!el) return null;
    if (el.tagName && el.tagName.toLowerCase() === 'a' && el.href) return el;
    if (el.closest) {
      const a = el.closest('a[href]');
      if (a && a.href) return a;
    }
    if (el.getAttribute) {
      const dh = el.getAttribute('data-href');
      if (dh) {
        const a = document.createElement('a');
        a.href = dh;
        return a;
      }
    }
    return null;
}
\end{lstlisting}
    \item \textbf{Cross-Frame Extraction:} Executes scripts across all \texttt{iframes} (\texttt{allFrames: true}) to capture links embedded in complex or nested page layouts.
\begin{lstlisting}[language=Java, caption=Cross-Frame extraction implementation]
async function getLinkFromAllFrames(tabId) {
    const results = await chrome.scripting.executeScript({
        target: { tabId, allFrames: true },
        func: () => {
            return {
                href: globalThis.__linkUnderCursor ?? null, 
                frameHref: location.href
            };
        }
    });
    for (const r of results) {
        if (r?.result?.href) return r.result;
    }
    return null;
}
\end{lstlisting}
\end{itemize}

\textbf{Real-time Tracking:} Maintains a global reference to the element currently under the user's cursor through continuous event listeners, ensuring zero-latency extraction upon command.

\begin{lstlisting}[language=Java, caption=Real-time checking implementation]
function updateFromTarget(target) {
    const anchor = resolveAnchor(target);
    if (anchor) {
      globalThis.__linkUnderCursor = anchor.href;
      globalThis.__linkUnderCursorTitle = anchor.textContent?.trim() || anchor.title;
    } else {
      globalThis.__linkUnderCursor = null;
    }
}
// Continuous event listeners for real-time tracking
const opts = { capture: true, passive: true };
document.addEventListener('mousemove', (e) => updateFromTarget(e.target), opts);
document.addEventListener('mouseover', (e) => updateFromTarget(e.target), true);
document.addEventListener('focusin', (e) => updateFromTarget(e.target), true);
\end{lstlisting}
% \subsection{User Interaction and URL Extraction}
% The browser extension supports multiple extraction paths to minimize false negatives:
% \begin{itemize}
%     \item direct link scanning via the context menu (\texttt{linkUrl}),
%     \item scanning selected text if it matches a URL pattern,
%     \item a fallback link-under-cursor strategy for non-standard HTML structures.
% \end{itemize}

\subsection{Duplicate-scan Prevention}
To reduce redundant analysis and accidental repeated submissions, the local server maintains a small in-memory cache of recently scanned URLs and rejects duplicate requests during an active analysis session.

\begin{lstlisting}[language=Python, caption=duplicate prevention implementation]
analyzed_urls = set()  
@server.post('/download')
def download():
    # ... Authentication check ...
    
    data = request.get_json(silent=True) or {}
    url = (data.get('url') or '').strip()
    
    # [CHECK] Duplicate-scan Prevention Logic
    if url in analyzed_urls:      # Verify if the URL exists in the in-memory cache
        print(f"[LocalServer] URL already analyzed: {url}")
        
        # Reject duplicate requests with a 409 Conflict status
        return jsonify({
            'ok': False, 
            'error': 'duplicate', 
            'message': 'You cannot scan the same link twice! Close the analysis window to scan again.'
        }), 409
    
    print(f"[LocalServer] Received URL from extension: {url}")
    
    # Add URL to cache to prevent redundant analysis during the active session
    analyzed_urls.add(url)  
    
    if link_callback:
        link_callback(url)

    return jsonify({'ok': True, 'url': url, 'message': 'Analysis started'})
\end{lstlisting}